title: 漫谈微信支付-扫码支付
toc: false
date: 2016-07-15 07:56:20
categories: PHP
tags: [PHP, 支付] 
description: 漫谈微信支付-扫码支付
---

![](http://7xrc03.com1.z0.glb.clouddn.com/%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98.jpeg)
本文对微信扫码支付的实现过程进行详细介绍。
<!--more-->

## 概述
扫码支付应用于在各种场景下进行二维码支付，支付流程一般为：
- 商户根据微信支付规则为不同商品生成二维码；
- 用户使用微信扫一扫功能，扫码获取商品支付信息；
- 用户输入支付密码，完成支付；
- 用户微信客户端收到支付成功通知，微信后台将支付结果回调给商户后台。

## 支付模式
根据应用场景的不同，微信提供了两种扫码支付模式：
**模式一：**
商户将productid（可定义为产品标识或订单号）作为参数根据微信支付规则事先生成固定的二维码，商户可将此二维码打印张贴，方便用户线下扫码支付。
用户扫码后，微信支付系统会将用户openid和商户定义的productid返回给商户在微信公共平台配置的回调地址，商户根据productid生成微信支付交易，最后微信支付系统发起用户支付流程。
**模式二：**
商户后台主动发起调用微信支付[统一下单](https://pay.weixin.qq.com/wiki/doc/api/native.php?chapter=9_1)接口生成预付交易，并将接口返回的短连接生成二维码，用户扫码后输入密码完成支付交易。
## 实现过程
### 模式一：
- 准备工作：
模式一需要在微信公共平台配置回调地址：微信公共平台->微信支付->开发配置
![模式一回调配置](http://7xrc03.com1.z0.glb.clouddn.com/%E6%89%AB%E7%A0%81%E6%94%AF%E4%BB%98-%E5%9B%9E%E8%B0%83.png)
- 开发流程：
◆ 商户后台根据微信支付规则生成二维码，展示给用户；
◆ 用户扫描二维码，微信支付系统将用户openid和productid以参数方式回调商户在公共平台设置的回调地址；
◆ 商户后台系统接收到微信回调请求，根据接收到openid和productid生成商户订单；
◆ 商户后台调用微信支付[统一下单](https://pay.weixin.qq.com/wiki/doc/api/native.php?chapter=9_1)接口获取预付交易id（prepay_id）；
◆ 微信支付系统根据商户统一下单请求生成预支付交易，返回prepay_id；
◆ 商户系统得到prepay_id后返回给微信支付系统；
◆ 微信支付系统接收到prepay_id后发起用户端微信支付流程（拉起微信支付，输入密码，完成扣款）；
◆ 微信支付系统完成交易后向用户微信客户端发送支付结果通知；
◆ 微信支付系统通过发送异步消息，将支付结果发送至商户统一下单时填写的回调地址；
◆ 商户确认微信支付结果并更新订单状态，如商户后台未收到微信支付结果通知，可以通过调用[查询订单](https://pay.weixin.qq.com/wiki/doc/api/native.php?chapter=9_2)接口主动查询订单支付结果。

- 实现
◆ 所需文件
lib/* ：PHP-SDK lib文件夹；
WxPay.NativePay.php：扫码支付实现类；
```php
<?php
require_once "wxPay/WxPay.Api.php";

/**
 * 扫码支付实现类
 */
class NativePay
{
	/**
	 * 
	 * 生成扫描支付URL,模式一
	 * @param BizPayUrlInput $bizUrlInfo
	 */
	public function GetPrePayUrl($productId)
	{
		$biz = new WxPayBizPayUrl();
		$biz->SetProduct_id($productId);
		$values = WxpayApi::bizpayurl($biz);
		$url = "weixin://wxpay/bizpayurl?" . $this->ToUrlParams($values);
		return $url;
	}
	
	/**
	 * 
	 * 参数数组转换为url参数
	 * @param array $urlObj
	 */
	private function ToUrlParams($urlObj)
	{
		$buff = "";
		foreach ($urlObj as $k => $v)
		{
			$buff .= $k . "=" . $v . "&";
		}
		
		$buff = trim($buff, "&");
		return $buff;
	}
	
	/**
	 * 
	 * 生成直接支付url，支付url有效期为2小时,模式二
	 * @param UnifiedOrderInput $input
	 */
	public function GetPayUrl($input)
	{
		if($input->GetTrade_type() == "NATIVE")
		{
			$result = WxPayApi::unifiedOrder($input);
			return $result;
		}
	}
}
```
◆ 生成二维码
```php
$productid = '123456789';
$notify = new NativePay();
$url = $notify->GetPrePayUrl($productid);
```
返回的二维码链接格式为：
```html
weixin://wxpay/bizpayurl?appid=wx426b3015555a46be&mch_id=1225312702&nonce_str=hscvjb7ljo9h53hsn97qhszd5wh5aja6&product_id=123456789&time_stamp=1468641555&sign=47FE32AA7DF1249D92353F1B6D79391A
```
使用QRcode将链接转换为二维码。

◆ 扫码支付回调
用户扫码完成后，微信支付系统会将用户openid和productid发送至该回调接口，该回调接口接收到微信回调请求后需要完成：
1） 调用微信支付统一下单接口获得prepay_id；
2） 将prepay_id返回给微信服务器。
首先创建实现微信扫码支付模式一的回调接口类`NativeNotifyCallBack`:
```php
class NativeNotifyCallBack extends WxPayNotify
{
	public function unifiedorder($openId, $product_id)
	{
		//统一下单
		$input = new WxPayUnifiedOrder();
		$input->SetBody("test");
		$input->SetAttach("test");
		$input->SetOut_trade_no(WxPayConfig::MCHID.date("YmdHis"));
		$input->SetTotal_fee("1");
		$input->SetTime_start(date("YmdHis"));
		$input->SetTime_expire(date("YmdHis", time() + 600));
		$input->SetGoods_tag("test");		
		//设置微信支付结果通知回调地址
		$input->SetNotify_url("http://XXX.com/test/WxPayCallBack");
		$input->SetTrade_type("NATIVE");
		$input->SetOpenid($openId);
		$input->SetProduct_id($product_id);
		$result = WxPayApi::unifiedOrder($input);		
		return $result;
	}
	
	public function NotifyProcess($data, &$msg)
	{
		//echo "处理回调";		
		
		if(!array_key_exists("openid", $data) ||
			!array_key_exists("product_id", $data))
		{
			$msg = "回调数据异常";
			return false;
		}
		 
		$openid = $data["openid"];
		$product_id = $data["product_id"];
		
		//统一下单
		$result = $this->unifiedorder($openid, $product_id);
		if(!array_key_exists("appid", $result) ||
			 !array_key_exists("mch_id", $result) ||
			 !array_key_exists("prepay_id", $result))
		{
		 	$msg = "统一下单失败";
		 	return false;
		 }
		
		$this->SetData("appid", $result["appid"]);
		$this->SetData("mch_id", $result["mch_id"]);
		$this->SetData("nonce_str", WxPayApi::getNonceStr());
		$this->SetData("prepay_id", $result["prepay_id"]);
		$this->SetData("result_code", "SUCCESS");
		$this->SetData("err_code_des", "OK");
		return true;
	}
}
```
在上一节[漫谈微信支付](http://yurixu.com/blog/2016/06/28/%E6%BC%AB%E8%B0%88%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98/)中介绍过微信回调基础类`WxPayNotify`，支付模式一的回调类`NativeNotifyCallBack`继承自`WxPayNotify`，NativeNotifyCallBack需要实现基类中定义的方法`NotifyProcess`进行回调逻辑处理。
`NativeNotifyCallBack`中`NotifyProcess`首先获取openid和product_id，然后传递给`unifiedorder`方法完成统一下单：
`$result = $this->unifiedorder($openid, $product_id);`接收统一下单返回的结果，并将appid、mch_id、nonce_str、prepay_id等信息返回给微信。

回调方法：
假设商户在公共号平台设置的回调地址为：http://XXXX.com/test/NativeCallBack
```php
public function NativeCallBack() {
	$notify = new NativeNotifyCallBack();
	$notify->Handle(true);
}
```
◆ 支付结果回调
支付结果回调用于接收微信服务器发送的支付结果通知，商户后台可能还需要执行更新订单状态以及其他操作。在统一下单接口中通过SetNotify_url进行设置。
首先定义处理微信支付结果的回调类`PayNotifyCallBack`:
```php
class PayNotifyCallBack extends WxPayNotify
{
	//查询订单
	public function Queryorder($transaction_id)
	{
		$input = new WxPayOrderQuery();
		$input->SetTransaction_id($transaction_id);
		$result = WxPayApi::orderQuery($input);		
		if(array_key_exists("return_code", $result)
			&& array_key_exists("result_code", $result)
			&& $result["return_code"] == "SUCCESS"
			&& $result["result_code"] == "SUCCESS")
		{
			return true;
		}
		return false;
	}
	
	//重写回调处理函数
	public function NotifyProcess($data, &$msg)
	{		
		$notfiyOutput = array();
		
		if(!array_key_exists("transaction_id", $data)){
			$msg = "输入参数不正确";
			return false;
		}
		//查询订单，判断订单真实性
		if(!$this->Queryorder($data["transaction_id"])){
			$msg = "订单查询失败";
			return false;
		}
		return true;
	}
}

```
`PayNotifyCallBack`同样继承自`WxPayNotify`，需要重写`NotifyProcess`方法。在微信支付结果回调中，`NotifyProcess`需要完成的操作是调用[查询订单](https://pay.weixin.qq.com/wiki/doc/api/native.php?chapter=9_2)接口，主动查询微信端订单状态。假设统一下单接口中定义的回调地址为：`http://XXX.com/test/WxPayCallBack`,
```php
	/**
     * 微信支付回调函数
     * @author yurixu 2015/6/26
     */
    public function actionWxPayCallBack(){
        require_once "WxPay.PayNotifyCallBack.php";
        $notify = new PayNotifyCallBack();
        $notify->Handle(true);        
    }
```
但是多数情况下商户后台在接收到微信支付结果通知后会进行订单状态变更以及一些业务逻辑操作，因此需要对SDK做一定修改。通过阅读SDK我们知道后台最终都是通过`WxpayApi::replyNotify`方法将结果以XML的格式直接输出，方便微信服务器接收，修改`WxpayApi::replyNotify`，将XML作为结果返回：
```php
	/**
	 * 直接输出xml
	 * @param string $xml
	 */
	public static function replyNotify($xml)
	{
		//echo $xml;
		//modify by yurixu 2015/6/26
		return $xml;
	}
```
此时`WxpayApi::replyNotify`修改为：
```php
	/**
     * 微信支付回调函数
     * @author yurixu 2015/6/26
     */
	public function actionWxPayCallBack(){
        require_once "WxPay.PayNotifyCallBack.php";
        $notify = new PayNotifyCallBack();
        $xml = $notify->Handle(true);
        $result = simplexml_load_string($xml);

        //支付成功
        if($result->return_code ==  'SUCCESS' && $result->return_msg == 'OK') {
            $postStr = $GLOBALS["HTTP_RAW_POST_DATA"];
            $postStr = simplexml_load_string($postStr);
            if($postStr) {
                $out_trade_no = $postStr->out_trade_no;         //订单号
                $transaction_id = $postStr->transaction_id;     //交易id
                //处理更新订单状态等其他业务逻辑
                $this->orderHandle($out_trade_no, $transaction_id);
            }
        }
        echo $xml;
    }    	
```
`orderHandle`方法用于处理商户后台订单逻辑，由于微信异步通知可能会多次发送给商户系统，因此商户后台业务处理逻辑**必须能够正确处理重复的通知**，如果是更新订单状态，在进行处理之前需要先进行订单状态判断，防止重复更新；如果处理逻辑中涉及到数据表插入等操作，要采用数据锁进行并发控制。例如使用Redis进行并发控制，key设置为用户ID+订单号

- 总结：
模式一需要事先在公共号平台配置支付回调URL，而且整个支付流程中涉及两部分微信回调过程，每个微信回调过程**对于支付结果通知的内容一定要做签名验证，防止数据泄漏导致出现“假通知”，造成资金损失。**

### 模式二：
- 开发流程：
- 总结：

## 支付模式区别