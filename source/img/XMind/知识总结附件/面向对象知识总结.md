# 面向对象知识总结

## 面向对象理解
### 概念
面向对象是一种程序设计理念，与程序语言无关。它将对象作为程序的基本单元，将属性和方法封装其中以提高软件的重用性、灵活性和扩展性。

### 类与对象
 **关系**：类是对象的抽象组织，对象是类的具体化存在；
 **内部存储**：类是属性和方法的集合，对象是属性的集合。同一个类创建的不同对象，拥有各自不同的属性，但是共享了类代码空间中方法区的代码。
``` php
typedef union _zvalue_value {
    long lval;
    double dval;
    struct {
        char *val;
        int len;
    } str;
    HashTable *ht;
    zend_object_value obj;
} zvalue_value;
```
`_zvalue_value`是PHP源码中对变量的定义，PHP是用C语言开发，union在C中表示结构体，它有如下特点：
```
1. union中可以定义多个成员，union的大小由最大的成员的大小决定；
2. union成员共享同一块大小的内存，一次只能使用其中的一个成员；
3. 对某一个成员赋值，会覆盖其他成员的值。
```
了解C语言中的union特点后即知道zvalue_value一次只能表示一种类型的变量，它可以表示整型、浮点型、字符串、数组（HashTable）和对象（zend_object_value），PHP中还有resource类型，是一个整型值，从而存储在lval中；bool类型用0和1表示，也存储在lval中；NULL类型没有任何意义，不需要用字段表示，因此直接使用C语言中的null表示。
PHP中的对象使用结构体`zend_object_value`存储：
```php
typedef struct _zend_object_value {
    zend_object_handle handle;   //  unsigned int类型，EG(objects_store).object_buckets的索引    
    zend_object_handlers *handlers;
} zend_object_value;
```
PHP内核中将所有对象保存到一个对象列表容器object_buckets中，因此handle字段就是在这个列表容器中的索引；字段handlers的类型是zend_object_handlers，这是一个包含了多个指针函数的结构体，这些指针函数包括对对象属性的操作，对对象方法的操作，克隆等。 此字段会在对象创建的时候初始化。
当我们需要在PHP中存储对象的时候， PHP内核会根据handle索引从对象列表object_buckets中获取相对应的对象。而获取的对象有其独立的结构：
```php
typedef struct _zend_object {
    zend_class_entry *ce;
    HashTable *properties;
    HashTable *guards; /* protects from __get/__set ... recursion */
} zend_object;
```
ce是存储该对象的类结构，在对象初始化时保存了类的入口；properties是一个HashTable，用来存放对象的属性；guards用来阻止递归调用。
![对象的组成](对象的组成.png)

### 魔术方法
PHP中以两个下划线'__'开头、具有特殊作用的一些方法叫魔术方法。
 **__get和__set**：
作用：访问和设置类中的私有属性。
示例：
```php
class People {
	private $name;
	//private static $sex;
	//const AGE = 19;
	
	public function say() {
		//echo "I am ".$this->name.", my age is ".self::AGE;
		echo "I am $this->name";
	}
}

$man = new People();
$man->name = 1;
//echo "Jim age is ".$jim::AGE."\n";
$man->say();
```
在没有定义__set方法时直接在类外部访问类私有属性，会产生错误：`PHP Fatal error:  Cannot access private property People::$name`，一般只能通过在类中定义一个public方法，然后在类外调用这个公开的方法实现对私有属性读写。现在可以通过__set和__get方法实现在类外部对私有属性的读写操作。
```php
class People {
	private $name;	
	
	public function __get($name) {
		if(!isset($this->name)) {			
			$this->name = 'yuri';
		}
		return $this->name;
	}
	public function __set($name, $value) {		
		$this->$name = $value;
	}
	public function say() {		
		echo "I am ".$this->name;
	}
}

$man = new People();
echo $man->name."\n";
$man->name = 'xyw';
$man->say();
```
注：类中定义的方法默认修饰符为public，即`public function __get($name)`等价于`function __get($name)`
 **__call和__callStatic**：
作用：

 **__toString**：
作用：输出对象字符串信息。

### 静态属性和静态方法

<table class="table table-bordered table-striped table-condensed">
   <tr>      
     <th colspan="5" bgcolor="F5F5F5" style="font-size:15px; padding:5px">静态属性和静态方法</th>     
   </tr>
   <tr>
      <td width="20%" style="text-align:center; font-weight:bold">调用对象</td>
      <td width="20%" style="text-align:center; font-weight:bold">静态属性</td>
      <td width="20%" style="text-align:center; font-weight:bold">非静态属性</td>
      <td width="20%" style="text-align:center; font-weight:bold">静态方法</td>
	  <td width="20%" style="text-align:center; font-weight:bold">非静态方法</td>
   </tr>
   <tr>
      <td rowspan="1" style="text-align:center">对象</td>
      <td width="20%" style="text-align:center">self::</td>
      <td width="20%" style="text-align:center">$this-></td>
      <td width="20%" style="text-align:center">self::或者$this-></td>
	  <td width="20%" style="text-align:center">$this-></td>
   </tr>
   <tr>
      <td rowspan="1" style="text-align:center">类</td>
      <td width="20%" style="text-align:center">self::</td>
      <td width="20%" style="text-align:center">—</td>
      <td width="20%" style="text-align:center">self::</td>
	  <td width="20%" style="text-align:center">—</td>
   </tr>
   <tr>
      <td rowspan="1" style="text-align:center">静态方法</td>
      <td width="20%" style="text-align:center">self::</td>
      <td width="20%" style="text-align:center">—</td>
      <td width="20%" style="text-align:center">self::</td>
	  <td width="20%" style="text-align:center">—</td>
   </tr>
   <tr>
      <td rowspan="1" style="text-align:center">非静态方法</td>
      <td width="20%" style="text-align:center">self::</td>
      <td width="20%" style="text-align:center">$this-></td>
      <td width="20%" style="text-align:center">self::或者$this-></td>
	  <td width="20%" style="text-align:center">$this-></td>
   </tr>   
</table>

```php
class People {	
	static public $sex = 'woman';		//静态属性
	public $name = 'yuri';				//非静态属性
		
	//非静态方法say
	public function say() {		
		echo "I am ".$this->name."\n";			//普通方法调用非静态属性
	}
	
	//静态方法sex
	public static function sex() {
		echo "My gender is ".self::$sex."\n";	//静态方法调用静态属性(注意：不要写成self::sex)
	}
	
	//非静态方法info
	public function info() {
		echo "I am ".$this->name."\n";			//普通方法调用非静态属性
		echo "My gender is ".self::$sex."\n";	//普通方法调用静态属性(注意：不要写成self::sex)
		$this->say();							//普通方法调用普通方法
		self::sex();							//普通方法调用静态方法
		$this->sex();							//普通方法调用静态方法
		
	}
	
	//静态方法walk
	public static function walk() {
		self::sex();							//静态方法调用静态方法
		echo "I can walk \n";
	}
}

echo People::$sex."\n";		//类调用静态属性(注意：不要写成People::sex)
People::sex();				//类调用静态方法
People::walk();				//类调用静态方法


$man = new People();
echo $man::$sex."\n";		//对象调用静态属性(注意：不要写成$man::sex)
echo $man->name."\n";		//对象调用非静态属性

$man::sex();				//对象调用静态方法
$man->sex();				//对象调用静态方法
$man::walk();				//对象调用静态方法

$man->say();				//对象调用非静态方法
$man->info();				//对象调用非静态方法
```
输出结果：
```
woman
My gender is woman
My gender is woman
I can walk
woman
yuri
My gender is woman
My gender is woman
My gender is woman
I can walk
I am yuri
I am yuri
My gender is woman
I am yuri
My gender is woman
My gender is woman
请按任意键继续. . .
```

[php面向对象中static静态属性和静态方法的调用](http://www.jb51.net/article/60871.htm)
[php中静态属性静态方法的用法](http://blog.sina.com.cn/s/blog_6f49a3c30100p43t.html)
### 类常量
[php类常量用法实例分析](http://www.jb51.net/article/69230.htm)

[1] [PHP变量在内存中的表示](http://gywbd.github.io/posts/2015/4/php-variable-in-memory.html)
[2] [PHP内核探索：对象](http://www.nowamagic.net/librarys/veda/detail/1521)